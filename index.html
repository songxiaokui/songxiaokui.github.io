<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>宋晓奎的学习生涯</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="宋晓奎的学习生涯">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="宋晓奎的学习生涯">
<meta property="og:locale" content="zh">
<meta property="article:author" content="宋晓奎">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="宋晓奎的学习生涯" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">宋晓奎的学习生涯</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">优秀的积累，造就优秀的复制</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Golang调度器GMP原理与调度全分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/18/Golang%E8%B0%83%E5%BA%A6%E5%99%A8GMP%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6%E5%85%A8%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2020-08-17T16:00:00.000Z" itemprop="datePublished">2020-08-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Golang/">Golang</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/18/Golang%E8%B0%83%E5%BA%A6%E5%99%A8GMP%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6%E5%85%A8%E5%88%86%E6%9E%90/">Golang调度器GMP原理与调度全分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一-Go调度器GPM分析"><a href="#一-Go调度器GPM分析" class="headerlink" title="一  Go调度器GPM分析"></a>一  Go调度器GPM分析</h1><ul>
<li><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><ul>
<li><h6 id="单进程"><a href="#单进程" class="headerlink" title="单进程"></a>单进程</h6><p><img src="https://cdn.learnku.com/uploads/images/202003/11/58489/06IoYRyruP.png!large" alt="单进程任务串行调度"></p>
<p>​        早起的操作系统是单核单任务执行，在进行进程调度时，会随着时间推移，CPU会进行调度，在一个时间段内执行一个进程，只有当一个进程执行完成之后，才能继续执行下一个进程。在一个时间段内，有且只有一个任务在被执行。每一个程序或者应用都是串行执行，执行效率低。</p>
<p>​        于是产生了以下问题：</p>
<p>​        单核执行，每次只能执行一个单一的流程；</p>
<p>​        如果被执行的进程任务被阻塞，则会带来CPU的浪费；</p>
<p>​        于是就有了后续的操作系统的并发操作，当CPU执行某个进程被阻塞时，CPU就会自动切换到其他等待执行的任务，并将挂起的任务的环境与上下文进行保存，这样可以继续执行其他的进程，避免了CPU的浪费与等待。    </p>
</li>
<li><h6 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h6><p>​        在多核操作系统中，同一时间、同一时刻多任务同时执行，每一个核都在同时进行任务的调度，每一个核的CPU同一时刻只有一个任务进行调度。</p>
</li>
<li><h6 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h6><p>​        在一个CPU进行多任务调度时，会按照时间片进行轮询调度执行任务，在一个CPU调度的时间轴中，一个时间点下，有且只有一个任务被调用。</p>
<p>​    <img src="https://cdn.learnku.com/uploads/images/202003/11/58489/sLve6TagD3.png!large" alt="CPU并发调度">        在多进程或多线程的操作系统中，解决了单任务的阻塞现象。只要某个进程产生阻塞，则CPU自动切换到其他的进程或线程进行执行，这样，每个进程在宏观上就表现的同时在执行。但是也会存在很多的问题。</p>
<p>​        不同进程之间的任务在CPU进行切换时，需要保存太多的系统资源以及上下文资源。进程的创建、切换、销毁都会占用过多的时间，如果进程的数量太多，则大部分的时间都浪费在进程之间的调度，缩短了进程的执行时间。</p>
<p>​        <img src="https://cdn.learnku.com/uploads/images/202003/11/58489/dNWd00AiEZ.png!large" alt="CPU工作流程"></p>
<p>​        在一个进程内，如果执行多线程，在os层线程的设计变得更加复杂，而且在同一个进程内的线程之间资源共享、锁的操作更加复杂。</p>
<p>​        多进程、多线程的壁垒：</p>
<p>​        高内存占用：开辟一个进程所占用的虚拟内存约4G（在32bit Os），开辟一个线程所需要占用的资源也要4M。</p>
<p>​        高CPU调度消耗：大部分的操作都在进行多任务切换时系统资源的消耗。</p>
</li>
<li><h6 id="协程-co-routine"><a href="#协程-co-routine" class="headerlink" title="协程 co-routine"></a>协程 co-routine</h6><p>​        协程是依赖与os 线程之上的’’用户态’’的线程，即用户态多任务的方式。</p>
<p>​        线程分为“内核态“线程和”用户态“线程，内核态线程，即os Thread，为CPU所识别的线程，由底层操 </p>
<p>作系统进行调用；用户态线程即协程，绑定在内核态线程之上。</p>
<p>​        <img src="https://cdn.learnku.com/uploads/images/202003/11/58489/TfStmYsfyF.png!large" alt="线程的内核与用户态"></p>
<p>​        如上图所示：CPU所能调度的是内核态线程，由操作系统所调度。CPU识别不了用户态线程，CPU视野之内只识别内核态线程。用户态线程即co-routine。</p>
<p>​        <img src="https://cdn.learnku.com/uploads/images/202003/11/58489/vgzlKzvOUL.png!large" alt="协程和线程"></p>
</li>
</ul>
</li>
<li><h4 id="协程模型"><a href="#协程模型" class="headerlink" title="协程模型"></a>协程模型</h4><ul>
<li><h6 id="协程与内核态线程N-1模型"><a href="#协程与内核态线程N-1模型" class="headerlink" title="协程与内核态线程N:1模型"></a>协程与内核态线程N:1模型</h6><p>​    <img src="https://cdn.learnku.com/uploads/images/202003/12/58489/kfPbThcyRU.png!large" alt="N:1模型"></p>
<p>​        如上图所示： N个协程绑定1个os Thread；</p>
<p>​        优点：多任务的切换在用户态线程下完成，不会陷入到内核态。切换非常迅速方便。</p>
<p>​        缺点： 一个进程上所有协程都绑定在一个内核态线程上，没有充分的使用硬件多核CPU加速处理的力；一旦某个执行的协程出现了阻塞现象，则这个进程中其他的协程都没办法继续执行下去，丧失了并发的能力，阻塞瓶颈；</p>
</li>
<li><h6 id="协程与内核态线程1-1模型"><a href="#协程与内核态线程1-1模型" class="headerlink" title="协程与内核态线程1:1模型"></a>协程与内核态线程1:1模型</h6><p>​        <img src="https://cdn.learnku.com/uploads/images/202003/11/58489/EhNQY2VCpk.png!large" alt="1:1模型">        1:1模型中，一个协程绑定一个线程，这样的模式和单线程其实没有太多的区别，协程的调度随着os thread的调度而调度，都是由CPU完成调度，也进行协程频繁的创建、切换与销毁，代价昂贵。</p>
</li>
<li><h6 id="协程与内核态线程N-M模型"><a href="#协程与内核态线程N-M模型" class="headerlink" title="协程与内核态线程N:M模型"></a>协程与内核态线程N:M模型</h6><p>​        <img src="https://cdn.learnku.com/uploads/images/202003/12/58489/ANDQLx3g9U.png!large" alt="M:N模型">        M:N模型，故名思义，是多个协程和多个os Thread进行绑定。</p>
<p>​        线程的调度是有CPU抢占式调度；协程的调度在用户态下通过协程调度器进行协作式调度，一个协程让出CPU之后，才会执行下一个协程；</p>
<p>​        优点：能够充分的利用多核的特效，进行多任务的调度与处理；</p>
<p>​        缺点：过于依赖协程调度器的优化与算法。</p>
</li>
</ul>
</li>
<li><h4 id="Go的协程goroutine"><a href="#Go的协程goroutine" class="headerlink" title="Go的协程goroutine"></a>Go的协程goroutine</h4><p>​        go中的协程，由co-routine改为goroutine，不仅仅是名字的更改，goroutine是用户态的线程，可以让一组可复用的函数运行在一组os Thread之上。即便协程出现阻塞，运行在该线程之上的其他协程也可以被runtime所调度，转移到其他可运行的线程上进行执行。goroutine非常的轻量，开辟一个协程只要几kb，并且几kb的资源就能将goroutine运行完成。</p>
<p>​        特点：</p>
<p>​        高并发：在有限的内存内，支持大量轻量级的goroutine，支持了更高的并发；</p>
<p>​        灵活调度：虽然在创建协程时分配的内存为几kb，但是如果业务需求，runtime会进行内存的扩充，伸缩调控，为goroutine进行内存分配。</p>
</li>
<li><h4 id="GM调度器"><a href="#GM调度器" class="headerlink" title="GM调度器"></a>GM调度器</h4><p>​        <img src="https://cdn.learnku.com/uploads/images/202003/11/58489/Af6GQ3GSlb.png!large" alt="GM含义">    <img src="https://cdn.learnku.com/uploads/images/202003/11/58489/uWk9pzdREk.png!large" alt="GM调度器"></p>
<p>​        G：goroutine协程</p>
<p>​        M：os Thread 内核态线程</p>
<p>说明:</p>
<p>​        一个进程内的有M1-M3个线程，每个线程要执行G或者放回G，必须要访问全局G队列。多线程对同一资源进行竞争时，会加锁对资源进行互斥与同步。所以，全局G队列是被锁进行保护。要想获取全局G队列中的goroutine，必须先获取锁，才能进行执行。</p>
<p>GM调度器缺陷：</p>
<p>​        创建、销毁、调度G都需要每个M获取锁，这就形成了激烈的锁竞争。</p>
<p>​        M转移G会造成延迟和额外的系统负载。比如当G中包含创建新协程的时候，M创建了G’，为了继续执行G，需要把G’交给M’执行，也造成了很差的局部性，因为G’和G是相关的，最好放在M上执行，而不是其他M’。 系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</p>
</li>
<li><h4 id="GMP调度器"><a href="#GMP调度器" class="headerlink" title="GMP调度器"></a>GMP调度器</h4><ul>
<li><h6 id="何为GPM"><a href="#何为GPM" class="headerlink" title="何为GPM"></a>何为GPM</h6><p>​        面对之前调度器的问题，Go设计了新的调度器。 在新调度器中，除了M(thread)和G(goroutine)，又引进了P(Processor)。</p>
<p>​        <em>G</em> 代表一个Goroutine；</p>
<p>​        <em>M</em> 代表一个操作系统的线程；</p>
<p>​        <em>P</em> 代表一个CPU处理器，通常P的数量等于CPU核数（<em>GOMAXPROCS</em>）；</p>
<p>​        其中：</p>
<p>​        G协程时运行在os Thread线程之上；</p>
<p>​        每一个要运行的线程，必须要和P（处理器）进行绑定，否则在全局线程队列中处理休眠状态，获取到P的线程分为执行线程、自旋线程。且程序中的多个<em>M</em>并不会同时都处于执行状态，最多只有GOMAXPROCS个线程在运行。</p>
<p>​        <img src="https://cdn.learnku.com/uploads/images/202003/11/58489/zaZ4nQYcZe.png!large" alt="GMP定义">        Processor，它包含了运行goroutine的资源，如果线程想运行goroutine，必须先获取P，P中还包含了运行的G队列，叫做P的本地队列。</p>
</li>
<li><h6 id="GMP模型"><a href="#GMP模型" class="headerlink" title="GMP模型"></a>GMP模型</h6><p>​        在Go中，线程是运行goroutine的实体，调度器的功能是把可运行的goroutine分配到工作线程上。</p>
</li>
</ul>
<p>​        <img src="https://cdn.learnku.com/uploads/images/202003/11/58489/Ugu3C2WSpM.jpeg!large" alt="GMP模型"></p>
<p>流程说明：</p>
<p>​        其一： 多核操作系统的硬件CPU被操作系统调度器所进行调度，从而对内核态的线程进行调度与执行；这个是由操作系统所进行的调度；</p>
<p>​        其二：每一个线程要执行goroutine时，必须先要和调度器P进行绑定，此时P会和起一个队列，为P的本地队列，进行存储将要执行的G。如果本地队列达到设置限制数量，则会将本地队列中一半的G和新创建的G放入到全局G队列中，等待被其他的线程所绑定的P进行获取与调度。当然如果创建新的G时，如果当前线程所绑定的P本地队列没有满，则优先加入到P的本地队列中。</p>
<p>​        其三：P队列，当程序运行时就会创建P处理器，并存储在列表中，即P的全局队列，其最大的数量为GOMAXPROCS的个数，可以使用runtime进行配置，每个线程会去对P进行竞争获取；</p>
<p>​        其四：线程M想要运行，就先要从P队列中获取P，并与之进行绑定，然后优先执行P的本地队列中的任务；当本地P队列中G数量为空时，便优先从全局G列中获取  min(len(GQ)/GOMAXPROCS + 1, len(GQ)/2)个goroutine放入到本地队列中，有P的G0进行调度；如果全局G队列也是空，则会从别的P中偷取一半的G放入到本地队列中进行执行(从尾部偷取)；</p>
<p>​        其五：goroutine调度器和os调度器通过线程M结合，os调度器负责将M运行在CPU内核上，而goroutine调度器则负责将协程在线程上进行切换，降低了内核态对线程切换资源的开销与延迟。</p>
<ul>
<li><h6 id="P与M数量问题"><a href="#P与M数量问题" class="headerlink" title="P与M数量问题"></a>P与M数量问题</h6><p>​        P：P的数量是通过环境变量中 GOMAXPROCS或者runtime.GOMAXPROCS(num)进行设置；默认当前服务器最大CPU核数；</p>
<p>​        M： go语言默认设置的最大线程数量为10000；当然可以有runtime/debug中的SetMaxThreads函数，设置M的最大数量；在实际运行过程中，当一个M阻塞时，将绑定的P-M进行解绑，然后先判断全局线程队列中是否存在空闲的M，如果没有，就会创建一个新的M。</p>
</li>
<li><h6 id="P与M的创建时机"><a href="#P与M的创建时机" class="headerlink" title="P与M的创建时机"></a>P与M的创建时机</h6><p>​        P何时创建：在确定了P的最大数量n后，运行时系统会根据这个数量创建n个P</p>
<p>​        M何时创建：没有足够的M来关联P并运行其中的可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。</p>
</li>
</ul>
</li>
<li><h4 id="GMP调度器调度策略"><a href="#GMP调度器调度策略" class="headerlink" title="GMP调度器调度策略"></a>GMP调度器调度策略</h4><ul>
<li><h6 id="复用线程"><a href="#复用线程" class="headerlink" title="复用线程"></a>复用线程</h6><p>​    复用线程：避免频繁的创建、销毁线程，而是对线程的复用，降低系统开销；</p>
<ul>
<li><h6 id="work-stealing"><a href="#work-stealing" class="headerlink" title="work stealing"></a>work stealing</h6><p>​        当本线程所绑定的本地队列P为空时，并且全局G队列中也没有可运行的G，此时将会从其他线程所绑定的P中去偷取一半的G（向下取整）进行调度执行。</p>
</li>
<li><h6 id="hand-off"><a href="#hand-off" class="headerlink" title="hand off"></a>hand off</h6><p>​        当本地线程执行的G任务进行阻塞，此时就会将P与M进行解绑，如果P中存在待执行的G，则P会从全局线程队列中获取一个空闲的M与之绑定继续执行；</p>
</li>
</ul>
</li>
<li><h6 id="利用并行"><a href="#利用并行" class="headerlink" title="利用并行"></a>利用并行</h6><p>​      GOMAXPROCS设置P的数量，最多有GOMAXPROCS个线程分布在多个CPU上同时运行。GOMAXPROCS也限制了并发的程度，比如GOMAXPROCS = 核数/2，则最多利用了一半的CPU核进行并行。</p>
</li>
<li><h6 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h6><p>​        在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。</p>
</li>
<li><h6 id="全局G队列"><a href="#全局G队列" class="headerlink" title="全局G队列"></a>全局G队列</h6><p>​        在新的调度器中依然有全局G队列，但功能已经被弱化了，当M执行work stealing从其他P偷不到G时，它可以从全局G队列获取G。</p>
</li>
</ul>
</li>
<li><h4 id="调度流程分析"><a href="#调度流程分析" class="headerlink" title="调度流程分析"></a>调度流程分析</h4><p>​        <img src="https://cdn.learnku.com/uploads/images/202003/11/58489/a4vWtvRWGQ.jpeg!large" alt="go func()调度分析">从上图我们可以分析出几个结论：</p>
<p>​        1、我们通过 go func()来创建一个goroutine；</p>
<p>​        2、有两个存储G的队列，一个是局部调度器P的本地队列、一个是全局G队列。新创建的G会先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中； </p>
<p>​        3、G只能运行在M中，一个M必须持有一个P，M与P是1：1的关系。M会从P的本地队列弹出一个可执行状态的G来执行，如果P的本地队列为空，就会想其他的MP组合偷取一个可执行的G来执行；</p>
<p>​        4、一个M调度G执行的过程是一个循环机制； </p>
<p>​        5、当M执行某一个G时候如果发生了syscall或则其余阻塞操作，M会阻塞，如果当前有一些G在执行，runtime会把这个线程M从P中摘除(detach)，然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P； </p>
<p>​        6、当M系统调用结束时候，这个G会尝试获取一个空闲的P执行，并放入到这个P的本地队列。如果获取不到P，那么这个线程M变成休眠状态， 加入到空闲线程中，然后这个G会被放入全局队列中。</p>
</li>
<li><h4 id="调度生命周期"><a href="#调度生命周期" class="headerlink" title="调度生命周期"></a>调度生命周期</h4><p>​        <img src="https://cdn.learnku.com/uploads/images/202003/11/58489/j37FX8nek9.png!large" alt="生命周期"></p>
<p>特殊的M0和G0 </p>
<p>​        <em>M0</em>： M0是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G， 在之后M0就和其他的M一样了。</p>
<p>​        <em>G0</em> ：G0是每次启动一个M都会第一个创建的gourtine，G0仅用于负责调度的G，G0不指向任何可执行的函数, 每个M都会有一个自己的G0。在调度或系统调用时会使用G0的栈空间, 全局变量的G0是M0的G0。</p>
<h6 id="代码实战分析"><a href="#代码实战分析" class="headerlink" title="代码实战分析"></a>代码实战分析</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hello world"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  接下来我们来针对上面的代码对调度器里面的结构做一个分析：</p>
<p> 也会经历如上图所示的过程： </p>
<p>​        其一：runtime创建起始线程M0和goroutine G0，并把2者关联。</p>
<p>​        其二：调度器初始化：初始化M0、栈、GC，以及创建和初始化由GOMAXPROCS个P构成的P列表。 示例代码中的main函数是main.main，runtime中也有1个main函数——runtime.main，代码经过编译后，runtime.main会调用main.main，程序启动时会为runtime.main创建goroutine，称它为main goroutin吧，然后把main goroutine加入到P的本地队列。 </p>
<p>​        其三：启动M0，M0已经绑定了P，会从P的本地队列获取G，获取到main goroutine。 </p>
<p>​        其四：G拥有栈，M根据G中的栈信息和调度信息设置运行环境 M运行G, 执行完协程后G退出，再次回到M。获取可运行的G，这样重复下去，直到main.main退出，runtime.main执行Defer和Panic处理，或调用runtime.exit退出程序。 </p>
<p>​        其五：调度器的生命周期几乎占满了一个Go程序的一生，runtime.main的goroutine执行之前都是为调度器做准备工作，runtime.main的goroutine运行，才是调度器的真正开始，直到runtime.main结束而结束。</p>
</li>
</ul>
<ul>
<li><h4 id="GPM可视化编程"><a href="#GPM可视化编程" class="headerlink" title="GPM可视化编程"></a>GPM可视化编程</h4><ul>
<li><h6 id="使用go-tool-trace-trace-out进行分析"><a href="#使用go-tool-trace-trace-out进行分析" class="headerlink" title="使用go tool trace trace.out进行分析"></a>使用go tool trace trace.out进行分析</h6><p>​        trace记录了运行时的信息，并提供了web进行可视化追踪；</p>
<p>​        简单测试代码：main函数创建trace，trace会运行在单独的goroutine中，然后main打印”Hello World”退出。</p>
<p>​        trace.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime/trace"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建trace文件</span></span><br><span class="line">    f, err := os.Create(<span class="string">"trace.out"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动trace goroutine</span></span><br><span class="line">    err = trace.Start(f)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> trace.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//main</span></span><br><span class="line">    fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序会得到一个trace.out文件；</p>
<p>使用工具进行打开：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> tool trace trace.out</span><br></pre></td></tr></table></figure>

<p>得到下列输出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">austsxkdeMacBook-Pro:tour austsxk$ <span class="keyword">go</span> tool trace trace.out </span><br><span class="line"><span class="number">2020</span>/<span class="number">08</span>/<span class="number">19</span> <span class="number">21</span>:<span class="number">53</span>:<span class="number">01</span> Parsing trace...</span><br><span class="line"><span class="number">2020</span>/<span class="number">08</span>/<span class="number">19</span> <span class="number">21</span>:<span class="number">53</span>:<span class="number">01</span> Splitting trace...</span><br><span class="line"><span class="number">2020</span>/<span class="number">08</span>/<span class="number">19</span> <span class="number">21</span>:<span class="number">53</span>:<span class="number">01</span> Opening browser. Trace viewer is listening on http:<span class="comment">//127.0.0.1:57842</span></span><br></pre></td></tr></table></figure>

<p>访问<strong><a href="http://127.0.0.1:57842" target="_blank" rel="noopener">http://127.0.0.1:57842</a></strong>,可以得到下面界面：</p>
<p><img src="../../post_img/trace1.png" alt="trace首页"></p>
<p>点击 View trace：</p>
<p><img src="../../post_img/trace2.png" alt="view trace"></p>
<p><strong>G 信息</strong></p>
</li>
</ul>
<p>​        点击 Goroutines 那一行可视化的数据条，我们会看到一些详细的信息。</p>
<p><img src="https://cdn.learnku.com/uploads/images/202003/11/58489/QLm0KK1hhd.png!large" alt="go-trace.png"></p>
<p>​         一共有两个G在程序中，一个是特殊的G0，是每个M必须有的一个初始化的G，这个我们不必讨论。</p>
<p>​        其中 G1 应该就是 main goroutine (执行 main 函数的协程)，在一段时间内处于可运行和运行的状态。</p>
<p>​        <strong>M 信息</strong></p>
<p>​        点击 Threads 那一行可视化的数据条，我们会看到一些详细的信息。</p>
<p><img src="https://cdn.learnku.com/uploads/images/202003/11/58489/mYYA4V17yF.png!large" alt="M信息"></p>
<p>​        一共有两个 M 在程序中，一个是特殊的 M0，用于初始化使用，这个我们不必讨论。</p>
<p>​        <strong>P 信息</strong></p>
<p>​        <img src="https://cdn.learnku.com/uploads/images/202003/11/58489/QbWwbth8uN.png!large" alt="P信息"></p>
<p>​        G1 中调用了 main.main，创建了 trace goroutine g18。G1 运行在 P1 上，G18 运行在 P0 上。</p>
<p>这里有两个 P，我们知道，一个 P 必须绑定一个 M 才能调度 G。</p>
<p>​        我们在来看看上面的 M 信息。</p>
<p><img src="https://cdn.learnku.com/uploads/images/202003/11/58489/5kS6NfpQAI.png!large" alt="M内部信息"></p>
<p>​        我们会发现，确实 G18 在 P0 上被运行的时候，确实在 Threads 行多了一个 M 的数据，点击查看如下：</p>
<p>​        多了一个 M2 应该就是 P0 为了执行 G18 而动态创建的 M2。</p>
<ul>
<li><h6 id="使用GODEBUG-schedtrace-时间段-可执行文件"><a href="#使用GODEBUG-schedtrace-时间段-可执行文件" class="headerlink" title="使用GODEBUG=schedtrace=时间段 可执行文件"></a>使用GODEBUG=schedtrace=时间段 可执行文件</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行go build trace2.go</p>
<p>得到一个可执行文件 trace2，然后进行GODEBUG运行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GODEBUG=schedtrace=<span class="number">1000</span> ./trace2 </span><br><span class="line">SCHED <span class="number">0</span>ms: gomaxprocs=<span class="number">2</span> idleprocs=<span class="number">0</span> threads=<span class="number">4</span> spinningthreads=<span class="number">1</span> idlethreads=<span class="number">1</span> runqueue=<span class="number">0</span> [<span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">Hello World</span><br><span class="line">SCHED <span class="number">1003</span>ms: gomaxprocs=<span class="number">2</span> idleprocs=<span class="number">2</span> threads=<span class="number">4</span> spinningthreads=<span class="number">0</span> idlethreads=<span class="number">2</span> runqueue=<span class="number">0</span> [<span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">Hello World</span><br><span class="line">SCHED <span class="number">2014</span>ms: gomaxprocs=<span class="number">2</span> idleprocs=<span class="number">2</span> threads=<span class="number">4</span> spinningthreads=<span class="number">0</span> idlethreads=<span class="number">2</span> runqueue=<span class="number">0</span> [<span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">Hello World</span><br><span class="line">SCHED <span class="number">3015</span>ms: gomaxprocs=<span class="number">2</span> idleprocs=<span class="number">2</span> threads=<span class="number">4</span> spinningthreads=<span class="number">0</span> idlethreads=<span class="number">2</span> runqueue=<span class="number">0</span> [<span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">Hello World</span><br><span class="line">SCHED <span class="number">4023</span>ms: gomaxprocs=<span class="number">2</span> idleprocs=<span class="number">2</span> threads=<span class="number">4</span> spinningthreads=<span class="number">0</span> idlethreads=<span class="number">2</span> runqueue=<span class="number">0</span> [<span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>

<p><strong>SCHED</strong>：调试信息输出标志字符串，代表本行是goroutine调度器的输出； </p>
<p><strong>0ms</strong>：即从程序启动到输出这行日志的时间；</p>
<p><strong>gomaxprocs</strong>: P的数量，本例有2个P, 因为默认的P的属性是和cpu核心数量默认一致，当然也可以通过GOMAXPROCS来设置；</p>
<p><strong>idleprocs</strong>: 处于idle状态的P的数量；通过gomaxprocs和idleprocs的差值，我们就可知道执行go代码的P的数量；</p>
<p><strong>threads</strong>: os threads/M的数量，包含scheduler使用的m数量，加上runtime自用的类似sysmon这样的thread的数量；</p>
<p><strong>spinningthreads</strong>: 处于自旋状态的os thread数量；</p>
<p><strong>idlethread</strong>: 处于idle状态的os thread的数量；</p>
<p><strong>runqueue=0</strong>： Scheduler全局队列中G的数量；</p>
<p><strong>[0 0]</strong>: 分别为2个P的local queue中的G的数量。</p>
</li>
</ul>
</li>
</ul>
<h1 id="二-Go调度器调度场景分析"><a href="#二-Go调度器调度场景分析" class="headerlink" title="二 Go调度器调度场景分析"></a>二 Go调度器调度场景分析</h1><ul>
<li><h3 id="局部性（协程创建的子协程添加到当前绑定的P-M的本地队列）"><a href="#局部性（协程创建的子协程添加到当前绑定的P-M的本地队列）" class="headerlink" title="局部性（协程创建的子协程添加到当前绑定的P-M的本地队列）"></a>局部性（协程创建的子协程添加到当前绑定的P-M的本地队列）</h3><p><img src="https://cdn.learnku.com/uploads/images/202003/11/58489/Pm8LOYcsWQ.png!large" alt="场景一:局部性.png"></p>
<p>​        当程序运行之后，P和M1进行绑定，P都是运行在绑定的M上；此时P的本地队列中有G1，正在进行运行，当G1运行中需要另起一个goroutine即G2时，使用go func() 创建，G2会优先添加到当前P-M所绑定的P本地队列。好处：子鞋程可能会共享资源，减少了资源复制以及上下文切换的CPU开销；即创建的些称会优先添加到与至向关的Processer中；</p>
</li>
<li><h3 id="协程执行完毕（使用每个M所创建的G0进行goroutine切换）"><a href="#协程执行完毕（使用每个M所创建的G0进行goroutine切换）" class="headerlink" title="协程执行完毕（使用每个M所创建的G0进行goroutine切换）"></a>协程执行完毕（使用每个M所创建的G0进行goroutine切换）</h3><p><img src="https://cdn.learnku.com/uploads/images/202003/12/58489/JWDtmKG3rK.png!large" alt="场景二"></p>
<p>​        如上图所描述：当G1执行完毕，M上运行的goroutine会先切换为G0，有G0统一负责调度协程切换(使用schedule进行调度),从本地队列P中获取goroutine,并开始执行协程(execute).从而实现了对os thread M1的重复使用.</p>
</li>
</ul>
<ul>
<li><h3 id="子协程的创建数目大于P限定的最大协程数目-无限开辟goroutine"><a href="#子协程的创建数目大于P限定的最大协程数目-无限开辟goroutine" class="headerlink" title="子协程的创建数目大于P限定的最大协程数目(无限开辟goroutine)"></a>子协程的创建数目大于P限定的最大协程数目(无限开辟goroutine)</h3><p><img src="https://cdn.learnku.com/uploads/images/202003/12/58489/UpjRxzIBd3.png!large" alt="场景三"></p>
<ol>
<li><p>如果G2创建6个协程,但是设置了所绑定的本地队列最大存储的goroutine的数目为4个.则前4个按照创建的局部性进行创建,在P1的本地队列中添加4个协程;</p>
<p><img src="https://cdn.learnku.com/uploads/images/202003/11/58489/chqTgsiuWi.png!large" alt="场景四"></p>
</li>
<li><p>G2还要继续创建协程G7,此时发现P1本地队列已经满了,则进行负载均衡, 则先将P1本地队列进行二分法,取出队头的一半,然后将任务和创建的G7打乱顺序,将其放入到全局队列中, P本地队列队尾的任务自动前移;</p>
<p><img src="https://cdn.learnku.com/uploads/images/202003/12/58489/nukEY92G6D.png!large" alt="场景五"></p>
</li>
<li><p>G2继续创建G8, 此时本地队列未满,将G8加入到本地队列P中;当时间轮询结束后,G2被加到本地队列中,等待调度;G8加入到P1点本地队列的原因还是因为P1此时在与M1绑定，而G2此时是M1在执行。所以G2创建的新的G会优先放置到自己的M绑定的P上。</p>
</li>
</ol>
</li>
</ul>
<ul>
<li><h3 id="创建G时唤醒自旋线程"><a href="#创建G时唤醒自旋线程" class="headerlink" title="创建G时唤醒自旋线程"></a>创建G时唤醒自旋线程</h3><p>​        <img src="https://cdn.learnku.com/uploads/images/202003/11/58489/2FWNXSuHfX.png!large" alt="场景六"></p>
<p>​        在创建协程时，就会去唤醒os Thread Queue中的M，尝试去进行与空闲的Processer进行绑定，进行P-M组合。如果没有M，则不进行操作；如果全局队列中有M或者存在多个M，则取出M，队列中剩余的M前移，如果没有空闲的P，则返回队列中；当有空闲的P时，则进行绑定，绑定之后，就会产生G0调度协程进行初始化与调度；如果新绑定的P本地队列中没有goroutine，则线程一直处于等待状态，尝试work stealing 或从全局中获取待执行的任务；在此期间，G0在一直寻找任务，此时的线程为自旋线程。</p>
</li>
</ul>
<ul>
<li><h3 id="GMP内部的负载均衡（被唤醒的线程从全局队列中获取G）"><a href="#GMP内部的负载均衡（被唤醒的线程从全局队列中获取G）" class="headerlink" title="GMP内部的负载均衡（被唤醒的线程从全局队列中获取G）"></a>GMP内部的负载均衡（被唤醒的线程从全局队列中获取G）</h3><p>​    <img src="https://cdn.learnku.com/uploads/images/202003/12/58489/0fn8DGqI8N.jpeg!large" alt="场景七"></p>
<p>​        当P-M组合完成后，G0将会不断的去寻找执行的G，会优先从GQ(Global Queue)中获取批量的G，如果GQ中存在待执行的goroutine，则会采用负载均衡的算法进行计算需要取出的G的数量；</p>
<p>​        函数：findrunnable()</p>
<p>​        计算公式：n = min(len(GQ)/GOMAXPROCS + 1, len(GQ)/2)</p>
<p>​        其中GQ为全局队列中保存的G的数量， GOMAXPROCS为设置的P的最大使用核数，一般默认为当前最大核数，然后计算出二者最小值为从全局队列中获取的数量，将其放入新P-M组合中P的本地队列中，然后由G0进行调度执行；</p>
<p>​        全局队列中其他的G，向前移动；一般从全局队列中取出的G至少一个；</p>
</li>
<li><h3 id="P本地队列和GQ皆为空时，从别地P中偷取G（M2从M1的本地队列中偷取goroutine）"><a href="#P本地队列和GQ皆为空时，从别地P中偷取G（M2从M1的本地队列中偷取goroutine）" class="headerlink" title="P本地队列和GQ皆为空时，从别地P中偷取G（M2从M1的本地队列中偷取goroutine）"></a>P本地队列和GQ皆为空时，从别地P中偷取G（M2从M1的本地队列中偷取goroutine）</h3><p>​    <img src="https://cdn.learnku.com/uploads/images/202003/12/58489/qn1NRMLqnp.png!large" alt="场景八"></p>
<p>​        当M2中的处理器P2将本地队列中的任务执行完毕后，并且此时全局队列也不存在G；此时M2将会执行work stealing 操作，从其他存在G的processer的本地队列中偷取一半的G，将其放在本地队列中；如上图所示，M2将从P1的尾部偷取一半的G（向下取整），即G8将被偷取存入到P2的本地队列中，然后又M2的G0进行调度执行;</p>
</li>
<li><h3 id="进程中没有可运行的G，自旋线程的最大数目-即GOMAXPROCS"><a href="#进程中没有可运行的G，自旋线程的最大数目-即GOMAXPROCS" class="headerlink" title="进程中没有可运行的G，自旋线程的最大数目(即GOMAXPROCS)"></a>进程中没有可运行的G，自旋线程的最大数目(即GOMAXPROCS)</h3><p>​    <img src="https://cdn.learnku.com/uploads/images/202003/12/58489/1DjlseEGTT.png!large" alt="场景九"></p>
<p>​        当进程中所有的线程M所绑定的P处理器本地队列中没有G，同时全局队列中无待执行的G时，此时进程中将会存在GOMAXPROCS数量个线程处于自旋状态；其他产生的线程将会保存在全局线程队列中处于休眠状态，等待下次被调度唤醒进行任务绑定；</p>
<p>​        如上图所示：当M1线程执行完G2， M2线程执行完G8，M1-M4都会处于自旋状态，配置GOMAXPROCS的数目为4；所以他们都会处于自旋状态，一直去寻找可以调度的G；自旋的本质其实是一直处于运行状态，只是没有执行G而已，其实也在浪费CPU资源。</p>
<p>​        不销毁这些自旋的线程的原因：在创建和销毁线程是很耗费CPU资源，也浪费时间；但是当新的goroutine被创建时，可以立刻有M进行执行，这样提高了执行的速率；如果之前销毁了线程，则新的goroutine被创建后，则需要重新创建M，并进行初始化G0等一系列初始化操作，增加了执行了时间，降低了执行的效率；所以这里采用了用空间替换时间，也只保留GOMAXPROCS个自旋线程，降低了过多线程对资源的消耗。</p>
</li>
</ul>
<ul>
<li><h3 id="Goroutine调度与阻塞"><a href="#Goroutine调度与阻塞" class="headerlink" title="Goroutine调度与阻塞"></a>Goroutine调度与阻塞</h3><p>​    <img src="https://cdn.learnku.com/uploads/images/202003/12/58489/k3HKE9U21M.png!large" alt="场景十"></p>
<p>​        如上图所示：系统中配置的最大处理器为4，此时M1线程正在执行G2， M2线程正在执行G8，G8协程在运行中产生G9，按局部原则，生成的G9优先加入到M2绑定的P2的本地队列中等待M2的G0进行调度；系统中M3和M4无任务执行，GQ中也无goroutine；此时M3和M4处于自旋状态或者将stealing 别的可用的P中的G；（进程运行中M数量远远大于P数量，M往往需要抢占调度P）</p>
<p>​        此处我们说的是当G9创建时，G8立马发生了阻塞了系统的调用；此时M2-P2将进行解绑；并且P2会进行一系列的判断：</p>
<p>​        如果P2本地队列有G，全局队列GQ中有G或者有空闲的M，那么P2将立马唤醒一个M与之绑定，并初始化G0，进行任务的调度；</p>
<p>​        如果P2没有G，那么P2将会添加到全局的P队列中，等待需要P的M取全局P队列中抢占P；</p>
<p>​        上图中，P2的本地队列中存在G9，则将会把P2-M2进行解绑，将从全局线程队列中获取M5并进行M5-P2的绑定，然后进行任务的调度；</p>
</li>
<li><h3 id="M-P记忆（M会记录曾经绑定的P）"><a href="#M-P记忆（M会记录曾经绑定的P）" class="headerlink" title="M-P记忆（M会记录曾经绑定的P）"></a>M-P记忆（M会记录曾经绑定的P）</h3><p>​        <img src="https://cdn.learnku.com/uploads/images/202003/12/58489/zBvpl8ENSb.png!large" alt="场景十一"></p>
<p>如上图所示：</p>
<p>​        M2线程正在执行G8，G8创建了协程G9，此时G8发生了阻塞；</p>
<p>​        M2-P2将会进行解绑；P2队列存在G9，所以P2将会和os 线程队列中的M进行绑定，但是此时M2将会记录P2；</p>
<p>​        然后G8和M2将会处于系统调用状态，当G8和M2退出系统调用时，M2将会尝试获取曾经绑定过的P2；        如果获取P2失败，则会从全局P队列中获取空闲的P与之绑定；</p>
<p>​        G8则会被标记为可运行状态，从而添加到全局的G队列中，等待被其他的P取从全局G队列中获取执行;</p>
<p>​        M2此时没有P与之绑定，则将处于休眠状态，添加到全局的M队列中，进行睡眠；</p>
<p>​        如果休眠时间到达一定时间，则将会被GC所消耗与回收；</p>
</li>
</ul>
<p>本文原创作者：刘丹冰aceld<br>参考文章来源: <a href="https://www.bilibili.com/read/cv5098443?share_source=weixin_moments&amp;share_medium=iphone&amp;bbid=Z14D6A1A795E4BA9420AADA64ED420451809&amp;ts=1595636745" target="_blank" rel="noopener">https://www.bilibili.com/read/cv5098443?share_source=weixin_moments&amp;share_medium=iphone&amp;bbid=Z14D6A1A795E4BA9420AADA64ED420451809&amp;ts=1595636745</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/18/Golang%E8%B0%83%E5%BA%A6%E5%99%A8GMP%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6%E5%85%A8%E5%88%86%E6%9E%90/" data-id="cke1kqrr200086k017ehxagiv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-并发常见问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/13/%E5%B9%B6%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2020-08-12T16:00:00.000Z" itemprop="datePublished">2020-08-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/GO%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%81%93/">GO语言并发之道</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/13/%E5%B9%B6%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">并发常见问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><h2 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h2><p>百度定义:</p>
<p>竞争条件指多个线程或者进程在读写一个共享数据时结果依赖于它们执行的相对时间的情形。<br>竞争条件发生在当多个进程或者线程在读写数据时，其最终的的结果依赖于多个进程的指令执行顺序。<br>多个进程并发访问和操作同一数据且执行结果与访问的特定顺序有关，称为竞争条件。</p>
<p>简单来说:<br>当两个或者多个操作必须按照正确的顺序执行,而程序并没有保证这个顺序,这就出现了竞争条件;通常会出现在一个并发操作读,另一个进行并发写入;</p>
<p>代码示例:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> number <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		number++</span><br><span class="line">		&#125;()</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> number == <span class="number">0</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"number = %v"</span>, number)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果可能性就存在三种情况:</p>
<p>情况一: 不输出任何东西,因为 if判断在number赋值之后进行执行;<br>情况二: number = 1,if判断在number之前执行,fmt输出在number之后执行;<br>情况三: number = 0,if判断和fmt输出都在number被赋值之前执行;</p>
<p>解决方案:<br>方案一: 在调试环境中使用,time睡眠,但是不是解决办法的有效方案;<br>方案二: 对变量操作进行原子操作,使用sync中的工具,比如互斥锁 读写锁等等;</p>
</li>
<li><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>定义: </p>
<p>​        具备在一定的环境下,即运行的上下文中,具有不可分割和不可中断的性质; 在这样的条件下,我们可以认为这个东西是原子的;</p>
<p>概念:</p>
<p>上下文(context):</p>
<p>​        一些操作在一个上下文中是原子的但是在另一个 上下文中就不一定是原子性操作;原子性会根据当前定义的范围的改变而发生改变;</p>
<p>不可分割和不可中断:</p>
<p>​        就是说在定义的上下文中,原子的东西将会被完整的运行,并且在这种情况下不会同时发生任何事情,也就是在原子内部是同步进行;</p>
<p>原子举例说明:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number <span class="keyword">int</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;number++&#125;()</span><br><span class="line"></span><br><span class="line">number ++ </span><br><span class="line"></span><br><span class="line">可以拆分:</span><br><span class="line"><span class="number">1.</span> 检索 number 值</span><br><span class="line"><span class="number">2.</span> 对 number 增加</span><br><span class="line"><span class="number">3.</span> 存储 number 值</span><br><span class="line">其中<span class="number">3</span>步都是原子操作,但是将其合在一起就不一定是原子操作,是否具备原子性,要看该操作所在的上下文环境中.</span><br><span class="line"></span><br><span class="line">如果该操作的上下文是: 无并发进程程序 则 number++ 是原子性</span><br><span class="line">如果该操作的上下文是: goroutine,并且number并没有给其他的goroutine中使用,则 也是原子性;</span><br></pre></td></tr></table></figure>

<p>综上所述:</p>
<p>​        在考虑原子性时,优先要确定的是就是定义上下文或者范围,然后再考虑这些操作是不是原子性,一切都应该遵守该原则; 大部分的操作都不是原子性,比如函数, 方法以及程序等.</p>
</li>
<li><h2 id="内存访问同步"><a href="#内存访问同步" class="headerlink" title="内存访问同步"></a>内存访问同步</h2><p>​        对同一个变量的访问或修改,在访问内存之前,进行获取锁操作,对变量进行业务处理完毕后,对该内存所持有的锁进行释放,以便于其他线程进行资源的访问与修改.</p>
<p>​        使用sync中的互斥锁或读写锁,可以实现了对该内存访问同步执行,保证数据安全性;弊端就是对程序的性能产生很大的影响, 并带来一系列锁的问题(死锁), 锁定的临界区域大小确定, 以及临界区是否会频繁的进入与退出等问题;</p>
<p>​                </p>
</li>
<li><h2 id="死锁-活锁-饥饿"><a href="#死锁-活锁-饥饿" class="headerlink" title="死锁 活锁 饥饿"></a>死锁 活锁 饥饿</h2></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/13/%E5%B9%B6%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" data-id="cke1kqrqy00036k0105ta25qe" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-golang反射reflect的使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/04/golang%E5%8F%8D%E5%B0%84reflect%E7%9A%84%E4%BD%BF%E7%94%A8/" class="article-date">
  <time datetime="2020-07-03T16:00:00.000Z" itemprop="datePublished">2020-07-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Golang/">Golang</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/04/golang%E5%8F%8D%E5%B0%84reflect%E7%9A%84%E4%BD%BF%E7%94%A8/">Golang中反射reflect的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Golang中的反射的使用"><a href="#Golang中的反射的使用" class="headerlink" title="Golang中的反射的使用"></a>Golang中的反射的使用</h2><ul>
<li><h2 id="反射的含义"><a href="#反射的含义" class="headerlink" title="反射的含义"></a>反射的含义</h2><p>​        反射能够在程序运行过程中探知对象的类型以及对象的值，还可以获取内存结构。弥补了静态语言在动态行为的不足。反射实现了元编程的重要手段。</p>
<p>​        简单的说反射机制就是在运行时动态的调用对象的方法和属性，golang中使用reflect包可以实现反射。</p>
</li>
<li><h2 id="反射的基础"><a href="#反射的基础" class="headerlink" title="反射的基础"></a>反射的基础</h2><ol>
<li><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>变量包括变量的类型和变量的值</p>
<p>(type, value)</p>
<p>其中类型包括静态类型、内置类型。静态类型就是常见的几种类型 int bool float 等。内置类型就是runtime系统所能识别的类型。</p>
</li>
<li><h4 id="接口变量"><a href="#接口变量" class="headerlink" title="接口变量"></a>接口变量</h4><p>Golang的指定类型的变量的类型是静态的（也就是指定int、string这些的变量，它的type是static type），在创建变量的时候就已经确定，反射主要与Golang的interface类型相关（它的type是concrete type），只有interface类型才有反射一说。</p>
<p>每一个接口变量都维护一个pair对，其pair对是：(type, value)</p>
<p>value是实际变量值，type是实际变量的类型。一个interface{}类型的变量包含了2个指针，一个指针指向值的类型【对应concrete type】，另外一个指针指向实际的值【对应value】。</p>
<p>pair对在接口变量的连续赋值过程中是不变的。</p>
<p>interface及其pair的存在，是Golang中实现反射的前提。</p>
</li>
</ol>
<p>​        总而言之, 反射操作所需要的基本信息都是来自于接口变量。接口变量除了存储自身类型外，还会保存实际对象的类型数据。</p>
</li>
<li><h2 id="类型反射"><a href="#类型反射" class="headerlink" title="类型反射"></a>类型反射</h2><p>类型反射的入口函数:</p>
<p>func TypeOf(i interface{}) Type</p>
<p>该函数会将任何传入的对象转化为接口类型。</p>
<p>未完待续</p>
</li>
<li><h2 id="值反射"><a href="#值反射" class="headerlink" title="值反射"></a>值反射</h2><p>值反射的入口函数:</p>
<p>func ValueOf(i interface{}) Type</p>
<p>未完待续</p>
</li>
<li><h2 id="反射方法的调用"><a href="#反射方法的调用" class="headerlink" title="反射方法的调用"></a>反射方法的调用</h2><p>通过reflect.Value 来获取，也需要配合 Elem()</p>
<p>未完待续</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/04/golang%E5%8F%8D%E5%B0%84reflect%E7%9A%84%E4%BD%BF%E7%94%A8/" data-id="cke1kqrpl00006k01dbcz9ce0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-将有序数组放入到二叉树中" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/04/%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E6%94%BE%E5%85%A5%E5%88%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD/" class="article-date">
  <time datetime="2020-07-03T16:00:00.000Z" itemprop="datePublished">2020-07-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/04/%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E6%94%BE%E5%85%A5%E5%88%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD/">树-1-有序数组放入到二叉树中</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="将一个有序数组的元素放入到二叉树中"><a href="#将一个有序数组的元素放入到二叉树中" class="headerlink" title="将一个有序数组的元素放入到二叉树中"></a>将一个有序数组的元素放入到二叉树中</h2><ul>
<li><p>题目</p>
<p>​        将一个有序数组的元素放入到二叉树中，形成的二叉树为二叉搜索树。</p>
</li>
<li><p>实现思路:</p>
<p>​        1.获取数组的中间元素位置，构建根节点。</p>
<p>​        2.在将数组开始到中间元素前一个位置构造为节点的左子树。中间元素后一个到数组末尾元素构造为节点的右子树。</p>
<p>​        3.如果数组的开始位置等于结束位置，则返回。</p>
<p>​        4.递归调用进行构造。</p>
</li>
<li><p>图示说明</p>
<p>​        <img src="../../post_img/image-20200704143234773.png" alt="数组构造树"></p>
</li>
<li><p>实现代码    </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个节点的结构体</span></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 值域</span></span><br><span class="line">  Value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 左子节点</span></span><br><span class="line">  LiftNode *TreeNode</span><br><span class="line">  <span class="comment">// 右子节点</span></span><br><span class="line">  RightNode *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数，返回指针类型的一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">new</span>(TreeNode)</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组转化为树的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ArrayConvertTree</span><span class="params">(arr []<span class="keyword">int</span>, start, end <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定义一个跟节点</span></span><br><span class="line">	<span class="keyword">var</span> root *TreeNode</span><br><span class="line">	<span class="comment">// 只要结束节点大于等于开始节点</span></span><br><span class="line">	<span class="keyword">if</span> end &gt;= start &#123;</span><br><span class="line">		<span class="comment">// 构造一个根节点</span></span><br><span class="line">		root = Constructor()</span><br><span class="line">		<span class="comment">// 取出中间位置</span></span><br><span class="line">		mid := (start+end+<span class="number">1</span>)/<span class="number">2</span></span><br><span class="line">		<span class="comment">// 如果开始等于结束,该节点的左右节点都为nil</span></span><br><span class="line">		root.Value = arr[mid]</span><br><span class="line">		<span class="comment">// 该节点的左子节点</span></span><br><span class="line">		root.LiftNode = ArrayConvertTree(arr, start, mid<span class="number">-1</span>)</span><br><span class="line">		<span class="comment">// 该节点的右子节点</span></span><br><span class="line">		root.RightNode = ArrayConvertTree(arr, mid+<span class="number">1</span>, end)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树中序的遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TreeMid</span><span class="params">(t *TreeNode)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 如果节点为空</span></span><br><span class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	TreeMid(t.LiftNode)</span><br><span class="line">	fmt.Println(t.Value)</span><br><span class="line">	TreeMid(t.RightNode)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line">	fmt.Println(arr)</span><br><span class="line">	r := ArrayConvertTree(arr,<span class="number">0</span>, <span class="built_in">len</span>(arr)<span class="number">-1</span>)</span><br><span class="line">	<span class="comment">//fmt.Printf("%#v", r.Value, r.LiftNode.Value, r.RightNode.Value)</span></span><br><span class="line">	TreeMid(r)</span><br><span class="line">&#125;</span><br><span class="line">输出如下:</span><br><span class="line">输入的数组：</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">中序遍历的输出</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">一致</span><br></pre></td></tr></table></figure>


</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/04/%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E6%94%BE%E5%85%A5%E5%88%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD/" data-id="cke1kqrqu00016k010gz30xqt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-递归实现栈逆序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/01/%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%A0%88%E9%80%86%E5%BA%8F/" class="article-date">
  <time datetime="2020-06-30T16:00:00.000Z" itemprop="datePublished">2020-07-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/01/%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%A0%88%E9%80%86%E5%BA%8F/">栈与队列-3-递归实现栈的逆序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="递归实现栈的逆序"><a href="#递归实现栈的逆序" class="headerlink" title="递归实现栈的逆序"></a>递归实现栈的逆序</h2><ul>
<li><p>题目</p>
<p>​        将栈只用递归方式实现栈的逆序。</p>
</li>
<li><p>实现思路:</p>
<p>​        1.先获取到栈底元素，保持原栈的数据信息。</p>
<p>​        2.将每一步获取到的栈底元素最后押入到栈顶。</p>
</li>
<li><p>图示说明</p>
<p>​        1. 返回栈底元素，并将其移出掉</p>
<p>​        <img src="../../post_img/QQ20200709-191956@2x.png" alt="返回栈底元素并移除">        </p>
<p>​        2. 递归获取栈底元素，直到栈为空，在将获取到的元素押入到栈中。</p>
<p>​        <img src="../../post_img/image-20200701212925719.png" alt="栈元素逆序"></p>
</li>
<li><p>实现代码    </p>
<p>注意：本代码中的栈结构及其方法，引用上篇定义的栈结构及其方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">// 每次弹出栈底元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetAadRemoveLastElement</span><span class="params">(m *StackData)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	data, _ := m.Poll()</span><br><span class="line">	<span class="keyword">if</span> m.IsEmpty() &#123;</span><br><span class="line">		<span class="keyword">return</span> data</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		last := GetAadRemoveLastElement(m)</span><br><span class="line">		m.Add(data)</span><br><span class="line">		<span class="keyword">return</span> last</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归实现元素的翻转</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(d *StackData)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> d.IsEmpty() &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		result := GetAadRemoveLastElement(d)</span><br><span class="line">		<span class="comment">// 获取 1--2--3</span></span><br><span class="line">		Reverse(d)</span><br><span class="line">		<span class="comment">// 压入 3--2--1</span></span><br><span class="line">		d.Add(result)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	d := InitStack()</span><br><span class="line">	d.Data = []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">"1"</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	d.Length = <span class="number">3</span></span><br><span class="line">	fmt.Printf(<span class="string">"%#v\n"</span>, d.String())</span><br><span class="line">	Reverse(d)</span><br><span class="line">	fmt.Printf(<span class="string">"%#v\n"</span>, d.String())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="string">"[1 2 3]"</span></span><br><span class="line"><span class="string">"[3 2 1]"</span></span><br></pre></td></tr></table></figure>


</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/01/%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%A0%88%E9%80%86%E5%BA%8F/" data-id="ckc4dmu5a0003uu019li1d3z3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-双栈实现一个队列" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/30/%E5%8F%8C%E6%A0%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97/" class="article-date">
  <time datetime="2020-06-29T16:00:00.000Z" itemprop="datePublished">2020-06-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/30/%E5%8F%8C%E6%A0%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97/">栈与队列-2-由两个栈组成的队列</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="由两个栈组成的队列"><a href="#由两个栈组成的队列" class="headerlink" title="由两个栈组成的队列"></a>由两个栈组成的队列</h2><ul>
<li><p>题目</p>
<p>​        实现一个由两个栈组成的队列的接口，支持队列的基本操作：add、poll、peek。</p>
</li>
<li><p>实现思路:</p>
<p>​        栈：FILO</p>
<p>​        队列：FIFO</p>
<p>​        所以可以使用两个栈，正好将顺序调换从而实现类似队列的操作。</p>
<p>​        具体实现：</p>
<p>​        一个栈作为押入栈stackPush， 一个栈作为输出栈stackPop。押入时，正常将数据押入至stackPush。然后将数据弹出从stackPop栈中取出，这样栈的数据就可以实现队列的操作。注意: 1.stackPop栈，如果不为空，则不能将stackPush的数据押入栈中，也就是必须要将stackPop栈中的全部数据全部弹出后，才能押入数据。2. 在押入数据时，必须将stackPush栈的全部数据一次性全部押入stackPop栈中。</p>
<p>​        在押入stackPop的时机，在poll时，如果stackPop为空，则可以全部押入stackPush栈中的数据；在peek时，如果stackPop栈为空，也要将stackPush栈中的数据全部押入道stackPop中。</p>
</li>
<li><p>图示说明</p>
<p>​        <img src="../../post_img/image-20200630122712286.png" alt="图解双栈实现队列流程"></p>
</li>
<li><p>实现代码    </p>
<p>go中实现栈结构和接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造一个栈,实现add poll peek string接口</span></span><br><span class="line"><span class="keyword">type</span> Stack <span class="keyword">interface</span> &#123;</span><br><span class="line">	Add(<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	Poll()(<span class="keyword">interface</span>&#123;&#125;, error)</span><br><span class="line">	Peek()(<span class="keyword">interface</span>&#123;&#125;, error)</span><br><span class="line">	String()<span class="keyword">string</span></span><br><span class="line">	IsEmpty()<span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造一个保存栈数据的结构体</span></span><br><span class="line"><span class="keyword">type</span> StackData <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	Length <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使结构体逐一实现Stack全部接口</span></span><br><span class="line"><span class="comment">// 向栈添加数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StackData)</span> <span class="title">Add</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	s.Data = <span class="built_in">append</span>(s.Data, data)</span><br><span class="line">	s.Length ++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈弹出数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StackData)</span> <span class="title">Poll</span><span class="params">()</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> s.Length == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"stack is empty"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		data = s.Data[s.Length<span class="number">-1</span>]</span><br><span class="line">		s.Length --</span><br><span class="line">		s.Data = s.Data[:s.Length]</span><br><span class="line">		<span class="keyword">return</span> data, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取栈顶数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StackData)</span> <span class="title">Peek</span><span class="params">()</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> s.Length == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"stack is empty"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		data = s.Data[s.Length<span class="number">-1</span>]</span><br><span class="line">		<span class="keyword">return</span> data, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出栈的字符串信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StackData)</span> <span class="title">String</span><span class="params">()</span><span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprint(s.Data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StackData)</span> <span class="title">IsEmpty</span><span class="params">()</span><span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> s.Length == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数,初始化栈的信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitStack</span><span class="params">()</span> *<span class="title">StackData</span></span>&#123;</span><br><span class="line">	s := <span class="built_in">new</span>(StackData)</span><br><span class="line">	s.Data = []<span class="keyword">interface</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	s.Length = <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用双栈实现一个队列代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现一个接口,使用双栈实现队列的接口</span></span><br><span class="line"><span class="keyword">type</span> DoubleStackForQueueInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">	Add(<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	Poll()(<span class="keyword">interface</span>&#123;&#125;, error)</span><br><span class="line">	Peek()(<span class="keyword">interface</span>&#123;&#125;, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个结构体,保存两个栈信息</span></span><br><span class="line"><span class="keyword">type</span> DoubleStack <span class="keyword">struct</span> &#123;</span><br><span class="line">	StackPush StackData</span><br><span class="line">	StackPop StackData</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现双栈队列接口的全部方法</span></span><br><span class="line"><span class="comment">// ADD添加数据,栈的长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DoubleStack)</span> <span class="title">Add</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	d.StackPush.Add(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹出队列的数据,先判断stackPop是否为空,如果为空,则全部添加stackPush的数据信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DoubleStack)</span> <span class="title">Poll</span><span class="params">()</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> d.StackPop.IsEmpty() &#123;</span><br><span class="line">		<span class="comment">// 全量压入</span></span><br><span class="line">		<span class="keyword">for</span> !d.StackPush.IsEmpty() &#123;</span><br><span class="line">			di,_ := d.StackPush.Poll()</span><br><span class="line">			d.StackPop.Add(di)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	data, err = d.StackPop.Poll()</span><br><span class="line">	<span class="keyword">return</span> data, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前队列中的数据信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DoubleStack)</span> <span class="title">Peek</span><span class="params">()</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> d.StackPop.IsEmpty() &#123;</span><br><span class="line">		<span class="comment">// 全量压入</span></span><br><span class="line">		<span class="keyword">for</span> !d.StackPush.IsEmpty() &#123;</span><br><span class="line">			di,_ := d.StackPush.Poll()</span><br><span class="line">			d.StackPop.Add(di)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	data, err = d.StackPop.Peek()</span><br><span class="line">	<span class="keyword">return</span> data, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	stackPush := InitStack()</span><br><span class="line">	stackPop := InitStack()</span><br><span class="line">	doublequeue := DoubleStack&#123;</span><br><span class="line">		StackPush: *stackPush,</span><br><span class="line">		StackPop: *stackPop,</span><br><span class="line">	&#125;</span><br><span class="line">	doublequeue.Add(<span class="number">4</span>)</span><br><span class="line">	doublequeue.Add(<span class="number">3</span>)</span><br><span class="line">	doublequeue.Add(<span class="number">2</span>)</span><br><span class="line">	fmt.Println(doublequeue.StackPush.String(), doublequeue.StackPop.String())</span><br><span class="line">	d1, _ := doublequeue.Poll()</span><br><span class="line">	fmt.Println(d1)</span><br><span class="line">	d2, _ := doublequeue.Peek()</span><br><span class="line">	fmt.Println(d2)</span><br><span class="line">	doublequeue.Add(<span class="number">1</span>)</span><br><span class="line">	doublequeue.Add(<span class="number">0</span>)</span><br><span class="line">	fmt.Println(doublequeue.StackPush.String(), doublequeue.StackPop.String())</span><br><span class="line">	d3, _ := doublequeue.Poll()</span><br><span class="line">	fmt.Println(d3)</span><br><span class="line">	d4, _ := doublequeue.Poll()</span><br><span class="line">	fmt.Println(d4)</span><br><span class="line">	fmt.Println(doublequeue.StackPush.String(), doublequeue.StackPop.String())</span><br><span class="line">	d5, _ := doublequeue.Poll()</span><br><span class="line">	fmt.Println(d5)</span><br><span class="line">	fmt.Println(doublequeue.StackPush.String(), doublequeue.StackPop.String())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出信息如下：</span><br><span class="line">押入后数据，stackPush为押入，stackPop为空</span><br><span class="line">[<span class="number">4</span> <span class="number">3</span> <span class="number">2</span>] []</span><br><span class="line">弹出队列第一个押入的：</span><br><span class="line"><span class="number">4</span></span><br><span class="line">获取当前队列第一个：</span><br><span class="line"><span class="number">3</span></span><br><span class="line">继续押入<span class="number">1</span>，<span class="number">0</span>，stackPush押入，stackPop不动</span><br><span class="line">[<span class="number">1</span> <span class="number">0</span>] [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">继续弹出队列数据</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">此时stackPop为空，stackPush有后押入的<span class="number">1</span>，<span class="number">0</span></span><br><span class="line">[<span class="number">1</span> <span class="number">0</span>] []</span><br><span class="line">在此弹出，弹出<span class="number">1</span>，此时stackPush为空，stackPop中有<span class="number">1</span>，<span class="number">0</span>，<span class="number">1</span>被弹出</span><br><span class="line"><span class="number">1</span></span><br><span class="line">最后只剩下<span class="number">0</span></span><br><span class="line">[] [<span class="number">0</span>]</span><br><span class="line">押入顺序与输出顺序一致</span><br></pre></td></tr></table></figure>







</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/30/%E5%8F%8C%E6%A0%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97/" data-id="ckc4dmu4z0000uu011hamdxwg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-设计一个有getMin功能的栈" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/29/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%9C%89getMin%E5%8A%9F%E8%83%BD%E7%9A%84%E6%A0%88/" class="article-date">
  <time datetime="2020-06-28T16:00:00.000Z" itemprop="datePublished">2020-06-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/29/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%9C%89getMin%E5%8A%9F%E8%83%BD%E7%9A%84%E6%A0%88/">栈与队列-1-设计一个有getMin功能的栈</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="设计一个有getMin功能的栈"><a href="#设计一个有getMin功能的栈" class="headerlink" title="设计一个有getMin功能的栈"></a>设计一个有getMin功能的栈</h2><ul>
<li><p>题目</p>
<p>​    实现一个特殊功能的栈，在满足栈的基本功能的条件下，提供返回栈中最小元素的操作。</p>
</li>
<li><p>要求</p>
<p>​    pop、push、getMin操作的时间复杂度为O(1)</p>
</li>
<li><p>实现思路:</p>
<p>​    使用两个栈实现需求，一个栈用来保存正常栈的数据信息stackData，一个栈保存每一步的最小值stackMin。由stackData栈实现正常的pop和push，由stackMin栈实现获取当前栈的最小值。</p>
</li>
<li><p>实现方案</p>
<ul>
<li><p>方案一</p>
<p>​    对于stackMin保存每一步最小值，可以使用比较法进行保存，如果当前押入stackData的值小于等于stackMin栈顶的值，则将押入的数据保存stackMin栈中，大于stackMin栈顶的值，只押入stackData中。如果stackMin为空，则双栈都押入。弹出数据时，如果stackData弹出的数据等于当前stackMin栈顶元素，则stackMin栈顶元素也要弹出，即同步弹出。获取当前栈的最小值，直接获取stackMin栈顶元素即可。</p>
<p><img src="../../post_img/image-20200629230716521.png" alt="方案一比较押入"></p>
</li>
<li><p>方案二</p>
<p>​    stackMin栈数据重复保存法。将数据押入stackData栈中，如果押入栈中的数据小于等于stackMin栈顶元素，则stackData和stackMin都押入当前元素。如果押入栈中的数据大于stackMin栈顶元素，则获取stackMin栈顶元素，重复押入。如果stackMin栈为空，则直接将数据押入stackMin栈和stackData栈中。该方案以空间换取了部分比较的操作，对于弹出操作，双栈弹出即可。获取当前栈最小值方式同上。</p>
<p><img src="../../post_img/image-20200629231009666.png" alt="重复押入"></p>
</li>
</ul>
</li>
<li><p>go实现代码</p>
<ul>
<li><p>方案一实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义接口，要求实现push pop getMin三个方法</span></span><br><span class="line"><span class="keyword">type</span> GetMin <span class="keyword">interface</span>&#123;</span><br><span class="line">	push(<span class="keyword">int</span>)</span><br><span class="line">	pop() (<span class="keyword">int</span>, error)</span><br><span class="line">	getMin() (<span class="keyword">int</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体，有存储数据的栈 保存最小值的栈</span></span><br><span class="line"><span class="keyword">type</span> GetMinStack <span class="keyword">struct</span> &#123;</span><br><span class="line">	stackDate []<span class="keyword">int</span></span><br><span class="line">	stackMin []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使结构体实现所有方法，即GetMinStack结构体实现GetMin全部接口</span></span><br><span class="line"><span class="comment">// 数据押入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *GetMinStack)</span> <span class="title">push</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 实现押入方法</span></span><br><span class="line">	s.stackDate = <span class="built_in">append</span>(s.stackDate, num)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s.stackMin) == <span class="number">0</span> &#123;</span><br><span class="line">		s.stackMin = <span class="built_in">append</span>(s.stackMin, num)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 取出最后一个</span></span><br><span class="line">		<span class="keyword">if</span> last := s.stackMin[<span class="built_in">len</span>(s.stackMin)<span class="number">-1</span>]; num &lt;= last &#123;</span><br><span class="line">			s.stackMin = <span class="built_in">append</span>(s.stackMin, num)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据弹出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *GetMinStack)</span> <span class="title">pop</span><span class="params">()</span><span class="params">(num <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 弹出最后一个元素</span></span><br><span class="line">	length := <span class="built_in">len</span>(s.stackDate)</span><br><span class="line">	<span class="keyword">if</span> length == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> num, errors.New(<span class="string">"stack is empty"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	num = s.stackDate[length<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">if</span> last := s.stackMin[<span class="built_in">len</span>(s.stackMin)<span class="number">-1</span>]; last == num &#123;</span><br><span class="line">		s.stackMin = s.stackMin[:<span class="built_in">len</span>(s.stackMin)<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	s.stackDate = s.stackDate[:length<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> num, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前栈中最小值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *GetMinStack)</span> <span class="title">getMin</span><span class="params">()</span> <span class="params">(num <span class="keyword">int</span>, err error)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 获取最小值</span></span><br><span class="line">	<span class="keyword">if</span> length := <span class="built_in">len</span>(s.stackMin); length &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> num, errors.New(<span class="string">"statck is empty"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	num = s.stackMin[<span class="built_in">len</span>(s.stackMin)<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> num, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 设计一个具有获取最小值的stack</span></span><br><span class="line">	m := <span class="built_in">new</span>(GetMinStack)</span><br><span class="line">	m.stackMin = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	m.stackDate = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> n GetMin = m</span><br><span class="line">	n.push(<span class="number">2</span>)</span><br><span class="line">	n.push(<span class="number">2</span>)</span><br><span class="line">	n.push(<span class="number">3</span>)</span><br><span class="line">	n.push(<span class="number">4</span>)</span><br><span class="line">	n.push(<span class="number">1</span>)</span><br><span class="line">	fmt.Println(m.stackDate, m.stackMin)</span><br><span class="line">	mindata, err := n.getMin()</span><br><span class="line">	fmt.Println(mindata, err)</span><br><span class="line">	data,err := n.pop()</span><br><span class="line">	fmt.Println(data, err)</span><br><span class="line">	fmt.Println(m.stackDate, m.stackMin)</span><br><span class="line">	data1, err := n.pop()</span><br><span class="line">	fmt.Println(data1, err)</span><br><span class="line">	fmt.Println(m.stackDate, m.stackMin)</span><br><span class="line">	data2, err := n.pop()</span><br><span class="line">	fmt.Println(data2, err)</span><br><span class="line">	fmt.Println(m.stackDate, m.stackMin)</span><br><span class="line">	data3, err := n.pop()</span><br><span class="line">	fmt.Println(data3, err)</span><br><span class="line">	fmt.Println(m.stackDate, m.stackMin)</span><br><span class="line">	data4, err := n.pop()</span><br><span class="line">	fmt.Println(data4, err)</span><br><span class="line">	mindata1, err := n.getMin()</span><br><span class="line">	fmt.Println(mindata1, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">    [<span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span>] [<span class="number">2</span> <span class="number">2</span> <span class="number">1</span>]</span><br><span class="line">    <span class="number">1</span> &lt;<span class="literal">nil</span>&gt;</span><br><span class="line">    <span class="number">1</span> &lt;<span class="literal">nil</span>&gt;</span><br><span class="line">    [<span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>] [<span class="number">2</span> <span class="number">2</span>]</span><br><span class="line">    <span class="number">4</span> &lt;<span class="literal">nil</span>&gt;</span><br><span class="line">    [<span class="number">2</span> <span class="number">2</span> <span class="number">3</span>] [<span class="number">2</span> <span class="number">2</span>]</span><br><span class="line">    <span class="number">3</span> &lt;<span class="literal">nil</span>&gt;</span><br><span class="line">    [<span class="number">2</span> <span class="number">2</span>] [<span class="number">2</span> <span class="number">2</span>]</span><br><span class="line">    <span class="number">2</span> &lt;<span class="literal">nil</span>&gt;</span><br><span class="line">    [<span class="number">2</span>] [<span class="number">2</span>]</span><br><span class="line">    <span class="number">2</span> &lt;<span class="literal">nil</span>&gt;</span><br><span class="line">    <span class="number">0</span> statck is empty</span><br><span class="line">符合预期</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>方案二实现</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GetMin <span class="keyword">interface</span>&#123;</span><br><span class="line">	push(<span class="keyword">int</span>)</span><br><span class="line">	pop() (<span class="keyword">int</span>, error)</span><br><span class="line">	getMin() (<span class="keyword">int</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GetMinStack <span class="keyword">struct</span> &#123;</span><br><span class="line">	stackDate []<span class="keyword">int</span></span><br><span class="line">	stackMin []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二 押入时，判断最小栈的值。进行重复押入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *GetMinStack)</span> <span class="title">push</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 实现押入方法</span></span><br><span class="line">	s.stackDate = <span class="built_in">append</span>(s.stackDate, num)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s.stackMin) == <span class="number">0</span> &#123;</span><br><span class="line">		s.stackMin = <span class="built_in">append</span>(s.stackMin, num)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 取出最后一个</span></span><br><span class="line">		last := s.stackMin[<span class="built_in">len</span>(s.stackMin)<span class="number">-1</span>]</span><br><span class="line">		<span class="keyword">if</span> num &lt;= last &#123;</span><br><span class="line">			s.stackMin = <span class="built_in">append</span>(s.stackMin, num)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 重复押入</span></span><br><span class="line">			s.stackMin = <span class="built_in">append</span>(s.stackMin, last)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹出时，双栈弹出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *GetMinStack)</span> <span class="title">pop</span><span class="params">()</span><span class="params">(num <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 弹出最后一个元素</span></span><br><span class="line">	length := <span class="built_in">len</span>(s.stackDate)</span><br><span class="line">	<span class="keyword">if</span> length == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> num, errors.New(<span class="string">"stack is empty"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	num = s.stackDate[length<span class="number">-1</span>]</span><br><span class="line">	s.stackDate = s.stackDate[:length<span class="number">-1</span>]</span><br><span class="line">	s.stackMin = s.stackMin[:<span class="built_in">len</span>(s.stackMin)<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> num, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最小值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *GetMinStack)</span> <span class="title">getMin</span><span class="params">()</span> <span class="params">(num <span class="keyword">int</span>, err error)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 获取最小值</span></span><br><span class="line">	<span class="keyword">if</span> length := <span class="built_in">len</span>(s.stackMin); length &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> num, errors.New(<span class="string">"statck is empty"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	num = s.stackMin[<span class="built_in">len</span>(s.stackMin)<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> num, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 设计一个具有获取最小值的stack</span></span><br><span class="line">	m := <span class="built_in">new</span>(GetMinStack)</span><br><span class="line">	m.stackMin = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	m.stackDate = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> n GetMin = m</span><br><span class="line">	n.push(<span class="number">2</span>)</span><br><span class="line">	n.push(<span class="number">2</span>)</span><br><span class="line">	n.push(<span class="number">3</span>)</span><br><span class="line">	n.push(<span class="number">4</span>)</span><br><span class="line">	n.push(<span class="number">1</span>)</span><br><span class="line">	fmt.Println(m.stackDate, m.stackMin)</span><br><span class="line">	mindata, err := n.getMin()</span><br><span class="line">	fmt.Println(mindata, err)</span><br><span class="line">	data,err := n.pop()</span><br><span class="line">	fmt.Println(data, err)</span><br><span class="line">	fmt.Println(m.stackDate, m.stackMin)</span><br><span class="line">	data1, err := n.pop()</span><br><span class="line">	fmt.Println(data1, err)</span><br><span class="line">	fmt.Println(m.stackDate, m.stackMin)</span><br><span class="line">	data2, err := n.pop()</span><br><span class="line">	fmt.Println(data2, err)</span><br><span class="line">	fmt.Println(m.stackDate, m.stackMin)</span><br><span class="line">	data3, err := n.pop()</span><br><span class="line">	fmt.Println(data3, err)</span><br><span class="line">	fmt.Println(m.stackDate, m.stackMin)</span><br><span class="line">	data4, err := n.pop()</span><br><span class="line">	fmt.Println(data4, err)</span><br><span class="line">	mindata1, err := n.getMin()</span><br><span class="line">	fmt.Println(mindata1, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果如下</span></span><br><span class="line">    [<span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span>] [<span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span>]</span><br><span class="line">    <span class="number">1</span> &lt;<span class="literal">nil</span>&gt;</span><br><span class="line">    <span class="number">1</span> &lt;<span class="literal">nil</span>&gt;</span><br><span class="line">    [<span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>] [<span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span>]</span><br><span class="line">    <span class="number">4</span> &lt;<span class="literal">nil</span>&gt;</span><br><span class="line">    [<span class="number">2</span> <span class="number">2</span> <span class="number">3</span>] [<span class="number">2</span> <span class="number">2</span> <span class="number">2</span>]</span><br><span class="line">    <span class="number">3</span> &lt;<span class="literal">nil</span>&gt;</span><br><span class="line">    [<span class="number">2</span> <span class="number">2</span>] [<span class="number">2</span> <span class="number">2</span>]</span><br><span class="line">    <span class="number">2</span> &lt;<span class="literal">nil</span>&gt;</span><br><span class="line">    [<span class="number">2</span>] [<span class="number">2</span>]</span><br><span class="line">    <span class="number">2</span> &lt;<span class="literal">nil</span>&gt;</span><br><span class="line">    <span class="number">0</span> statck is empty</span><br><span class="line">符合预期</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>​    </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/29/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%9C%89getMin%E5%8A%9F%E8%83%BD%E7%9A%84%E6%A0%88/" data-id="ckc4dmu530001uu017lxn8ktb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-postgres安装教程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/17/postgres%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/" class="article-date">
  <time datetime="2020-06-16T16:00:00.000Z" itemprop="datePublished">2020-06-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/17/postgres%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/">postgresql数据库安装</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="postgres安装教程"><a href="#postgres安装教程" class="headerlink" title="postgres安装教程"></a>postgres安装教程</h2><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><pre><code>目前网上有很多mac安装postgres的教程，完全按照那些教程安装，有的可能会出现各种问题，使得安装失败。
经过自己的多次失败安装后，将在安装过程中的细节整理一二，希望有像我一样困扰的朋友得以解决问题；
本文档解决了mac上安装报错等问题，顺便提供了docker安装过程中的一 些需要注意的细节以及提供了Centos上使用源码安装postgres的步骤；
本人亲测可行，希望可以帮助需要的人。</code></pre><h1 id="1-mac安装PostgreSQL"><a href="#1-mac安装PostgreSQL" class="headerlink" title="1. mac安装PostgreSQL"></a>1. mac安装PostgreSQL</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 在mac的 系统偏好设置--&gt;用户与群组--&gt;解锁--&gt;点+--&gt;新建用户</span><br><span class="line">（注意：此处将用户选为管理员用户，可以不用重启电脑，选普通成员后续操作略有不同）</span><br><span class="line"></span><br><span class="line">建议新建用户为：postgres   密码自定</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200606212418707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjkyNjUx,size_16,color_FFFFFF,t_70" alt="截图如上"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2. 下载安装包</span><br><span class="line">下载地址：https:&#x2F;&#x2F;www.enterprisedb.com&#x2F;downloads&#x2F;postgres-postgresql-downloads</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200606212816181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjkyNjUx,size_16,color_FFFFFF,t_70" alt="版本自选"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. 打开下载的安装包，在安选择安装位置时，选择刚才新建的用户下的一个文件夹内（即 postgres用户下自拟一个文件夹）</span><br></pre></td></tr></table></figure>
<p>如图 ，将默认的这个文件位置：<br><img src="https://img-blog.csdnimg.cn/20200606213640158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjkyNjUx,size_16,color_FFFFFF,t_70" alt="文件目录选择"><br>替换为自建的postgres用户下:<br><img src="https://img-blog.csdnimg.cn/20200606213821449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjkyNjUx,size_16,color_FFFFFF,t_70" alt=""><br>然后一直next，其中包括密码要记住，后面登陆要用，注意在选择<img src="https://img-blog.csdnimg.cn/20200606214003250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjkyNjUx,size_16,color_FFFFFF,t_70" alt="字符集选择"><br>选择为: zh_CN.UTF8<br>然后继续next 即安装成功;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4. 在当前用户下，启动数据库</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200606214336372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjkyNjUx,size_16,color_FFFFFF,t_70" alt=""><br>打开后输入数据库相关信息，其他信息可以默认，但是密码是当时安装时的密码:<br><img src="https://img-blog.csdnimg.cn/20200606220605119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjkyNjUx,size_16,color_FFFFFF,t_70" alt="数据库登陆shell页面"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5. 终端使用</span><br><span class="line">\l 查看database</span><br><span class="line">create database hh；</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200606221130502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjkyNjUx,size_16,color_FFFFFF,t_70" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6. 使用pgAdmin4链接数据库</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200606221555914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjkyNjUx,size_16,color_FFFFFF,t_70" alt=""><br><img src="https://img-blog.csdnimg.cn/20200606221650288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjkyNjUx,size_16,color_FFFFFF,t_70" alt=""><br>连接成功<br><img src="https://img-blog.csdnimg.cn/20200606221732880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjkyNjUx,size_16,color_FFFFFF,t_70" alt=""><br>走到这里，基本上可以在代码里疯狂玩耍了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/17/postgres%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/" data-id="ckc0ombiq000012012naw086p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/GO%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%81%93/">GO语言并发之道</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/">Golang</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/08/18/Golang%E8%B0%83%E5%BA%A6%E5%99%A8GMP%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6%E5%85%A8%E5%88%86%E6%9E%90/">Golang调度器GMP原理与调度全分析</a>
          </li>
        
          <li>
            <a href="/2020/08/13/%E5%B9%B6%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">并发常见问题</a>
          </li>
        
          <li>
            <a href="/2020/07/04/golang%E5%8F%8D%E5%B0%84reflect%E7%9A%84%E4%BD%BF%E7%94%A8/">Golang中反射reflect的使用</a>
          </li>
        
          <li>
            <a href="/2020/07/04/%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E6%94%BE%E5%85%A5%E5%88%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD/">树-1-有序数组放入到二叉树中</a>
          </li>
        
          <li>
            <a href="/2020/07/01/%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%A0%88%E9%80%86%E5%BA%8F/">栈与队列-3-递归实现栈的逆序</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 宋晓奎<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
	<br>
	 <div style="width:200px; margin:0 auto; padding:2px 0;">
	 <a href="http://www.beian.miit.gov.cn/"  style="color:#f72b07" target="_blank">浙ICP备20022863号</a>

	</div>
	<div style="width:300px;margin:0 auto; padding:2px 0;">
	<a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33010402004239" style="display:inline-block;text-decoration:none;height:20px;line-height:20px;text-align: center">
          <img src="/img/back.png" style="float:left;"/>
          	<p style="float:left;height:20px;line-height:20px;margin: 0px 0px 0px 5px; color:#939393;">浙公网安备 33010402004239号
            </p>
					</a>
</div>	 
    </div>
	 <div style="width:400px;margin:0 auto; padding:2px 0;">	
	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div calss="count-span">
	<span id="busuanzi_container_site_pv">
		本站总访问量<span id="busuanzi_value_site_pv"></span>次
	</span>
	<span id="busuanzi_container_site_uv">
		本站总访客数<span id="busuanzi_value_site_uv"></span>人
	</span>
	<span id="busuanzi_container_page_pv">
		本文总阅读量<span id="busuanzi_value_page_pv"></span>次
	</span>
	</div>
	
	
<!--《添加网站运行时间 -->
<!--<br/>-->
<div style="width:350px;margin:0 auto; padding:2px 0;">
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
</div>
<script>
    var now = new Date();

    function createtime() {
        var grt = new Date("06/29/2020 12:00:00"); //此处修改你的建站时间或者网站上线时间 
        now.setTime(now.getTime() + 250);
        days = (now - grt) / 1000 / 60 / 60 / 24;
        dnum = Math.floor(days);
        hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum);
        hnum = Math.floor(hours);
        if (String(hnum).length == 1) {
            hnum = "0" + hnum;
        }
        minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes);
        if (String(mnum).length == 1) {
            mnum = "0" + mnum;
        }
        seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds);
        if (String(snum).length == 1) {
            snum = "0" + snum;
        }
        document.getElementById("timeDate").innerHTML = "   " +  " 本站已安全运行 " + dnum + " 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
    setInterval("createtime()", 300);
</script>
<!-- 添加网站运行时间》 -->	

  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>